# 页面性能优化

前端性能优化可以分为两大部分，浏览器和代码部分<br/>
浏览器部分又可以分为:

- 网络层面
- 浏览器渲染层面
- 服务端层面

代码部分又可以分为:

- 构建层面
- 编码层面
- 机制(SSR,英文 Server Side Render：服务端渲染)
- 规范
  首先看看浏览器部分，前端页面主要在浏览器上运行，那么我们追根溯源，从浏览器的原理开始，研究如何进行页面性能优化

## 浏览器组成部分

1. 用户界面
2. 浏览器引擎（browser engine）- 在用户界面和渲染引擎之间传递指令
3. **渲染引擎**（rendering engine）- 负责显示请求的内容
   浏览器（Firefox、chrome、Safari）是基于两种渲染引擎构建的，Firefox 使用的是 Gecko 引擎，chrome 和 Safari 使用的是 Webkit 引擎，Webkit 引擎又分为渲染引擎和 JS 引擎，渲染引擎负责显示请求的内容，JS 引擎负责解析和执行 JS 代码
4. 网络（Networking）- 用于网络调用，比如 HTTP 请求
5. UI 后端（UI Backend）- 用于绘制基本的窗口小部件，比如组合框和窗口
6. Javascript 解释器（Javascript Interpreter）- 用于解析和执行 Javascript 代码，如 V8 引擎
   js 引擎线层负责解析 javascript 脚本,运行代码。
   **JS 引擎一直等待任务队列中任务的到来，然后加以处理，一个 Tab 页面中只有一个 js 线层在运行**
7. 数据存储（data storage）- 负责将渲染引擎输出的内容进行持久化存储，例如 cookie，新的 HTML5 定义了网络数据库，这是一个完成的浏览器内数据库

## 浏览器是多进程的

进程线层简单理解，进程里面可以有多个线层，进程是 QQ，线层是会话

- 浏览器是多进程的
- 浏览器之所以能够运行，是因为系统给他的进程分配了资源(CPU、内存、磁盘)
- 简单理解每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程
  浏览器里面的进程：

1. Browser 进程，浏览器的主要进程（负责协调和主控），只有一个。作用有：

   - 负责浏览器界面显示，与用户交互。如前进、后退等
   - 负责各个页面的管理，创建和销毁其他进程
   - 将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上
   - 网络资源的管理，下载等

2. 第三方插件进程，每种类型的插件对应一个进程，多个插件进程可能同时存在。仅当使用了该插件才创建
3. GPU 进程，最多一个，用于 3D 绘制等
4. 浏览器渲染进程（浏览器内核），内部是多线层的

   - 默认每个 Tab 页面一个进程，互不影响
   - 主要作用为页面渲染，脚本执行，事件处理等

渲染进程是多线层的：

1. GUI 渲染线层

   - 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等
   - 当界面需要重绘制（Repaint）或某种操作引发的回流（Reflow），该线层就会执行
   - 注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

2. JS 引擎线层

   - 也称为 JS 内核，负责处理 Javascript 脚本程序（包括解析和执行），例如 V8 引擎
   - JS 引擎线层负责解析 JS 脚本，运行代码
   - JS 引擎一直等待任务队列中任务的到来，然后加以处理，一个 Tab 页面中只有一个 JS 引擎在运行
   - 注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，要放在 Body 下面，负责会导致页面渲染加载阻塞

3. 事件触发线程

   - 管理事件队列
   - 监听事件，符合条件时把回调函数放入事件队列中

4. 定时触发器线层

   - setInterval 与 setTimeout 在此线层中计时完毕，把回调函数放入事件队列
   - 浏览器定时计数并不是由 Javascript 引擎计数的，由单独的定时计数器线程来计时，计时完毕后，添加到事件队列中，等待 JS 引擎空闲时执行（因为 Javascript 引擎是单线程的，如果处于阻塞线层状态就会影响计时的准确，因此通过单独的线层来计时并触发定时（计时完毕后，添加到时间队列中，等待 JS 引擎空闲后执行）

5. 异步 http 请求线程

   - 检测 XHR 对象状态的变化时，将回调函数添加到事件队列中
   - 将检测到状态更新时，如果设置回调函数，异步线层就产生状态变更事件，将这个回调再放入事件队列中，由 javascript 引擎执行

了解一下执行线:

## 浏览器渲染机制简介

对于渲染，我们首先需要了解一个概念，设备刷新率。

设备刷新率是设备屏幕的渲染频率，通俗一点就是，把屏幕当作墙，设备刷新率就是多久刷新一次墙面，几本我们平常接触的设备，如手机、电脑等，刷新率一般为 60Hz，即每秒刷新 60 次。约 16.7ms 渲染一次屏幕<br/>
这就意味着，我们的浏览器最佳的渲染性能就是所有的操作都在 16.7ms 内完成，如果做到一帧内完成，那么浏览器渲染性能就最佳了。

渲染引擎一开始会从网络层获取请求文档的内容，内容大小一般限制在 8000 块以内<br/>
然后进行如下所示的**几本流程:**
![browser](/browser02.png)
渲染引擎开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点，同时解析外部 CSS 文件以及样式元素中的数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构，呈现树。
呈现树包含多个带有视觉属性(颜色和尺寸)的矩形，这些矩形的排列顺序就是它们将要在页面上的显示顺序。

呈现树构建完毕之后，进入“布局”处理阶段，也就是为节点分配一个应出现在屏幕上的确切坐标，下一阶段是**绘制**，渲染引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来

需要着重指出的是，这是一个渐进的过程，为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上，它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局，在不断接受和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来

那么我们知道了，CSSOM 树和 DOM 树合并成渲染树，然后用户计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。优化上述每一个步骤对实现最佳渲染性能至关重要

具体流程为:

- DOM 树与 CSS 树合并后形成渲染树
- 渲染树只包含渲染网页所需的节点
- 布局计算每个对象的精确位置和大小
- 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上
  > 请注意 visibility:hidden 和 display:none 的区别，前者元素仍在 DOM 树中，只是不可见，而后者元素不在 DOM 树中，因此，visibility:hidden 的元素不会影响计数器，而 display:none 的元素会影响计数器

**script 标签的处理**

JS 可以操作 DOM 来修改 DOM 结构，可以操作 CSSOM 来修改节点样式，这就导致了浏览器在解析 HTML 时，一旦碰到 script，就会立即停止 HTML 的解析（而 css 不会），执行 js，再返回控制权

事实上，JS 在执行前不仅仅是停止了 HTML 的解析，它还必须等待 CSS 的解析完成，当浏览器碰到 script 元素时，发现该元素当前的 css 还未解析完，就会等待 css 解析完毕，再去执行 js。

JS 阻塞了 HTML 的解析，也阻塞了其后的 css 解析，整个解析进程必须等待 JS 的执行完毕才能继续，这就是 JS 阻塞页面。一个 script 标签，推迟了 DOM 的生成，CSSOM 的生成以及之后的所有渲染过程，从性能角度上讲，将 script 放在页面底部，也就合情合理了。

简单来说，渲染线层和 JS 线程是互斥的，当 JS 执行时，渲染线程会被挂起，GUI 更新会被保存在一个队列中等待 JS 线程空闲时立即被执行。

总结一下浏览器的渲染流程:

- DOM 树构建
- CSSOM 树构建
  > css 加载不会阻塞 DOM 树的解析（异步加载时 DOM 树照常构建），但是会阻塞 render 树的渲染（渲染会等待 css 加载完毕，因为 render 树需要 css 信息）
- 布局
- 绘制

## 重排 reflow 和重绘 repaint

### 重排 reflow

relow 指的是重新计算页面布局
某个节点 reflow 时会重新计算节点的尺寸和位置，而且还有可能触发其子节点，祖先节点和页面上的其他节点 reflow，在这之后再触发一次 repaint

当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就称为回流(reflow)，每一个页面至少需要一个回流在页面第一次加载的时候

导致 reflow 的操作

- 调整窗口大小
- 改变字体
- 增加或移除样式表
- 内容变化，比如用户在 input 框中输入文字
- 激活伪类，比如:hover
- 操作 class 属性
- 脚本操作 DOM
- 计算 offsetWidth 和 offsetHeight 等属性
- 设置 style

触发页面重布局的 css 属性

- 盒模型相关的属性会触发重布局
  - width
  - height
  - padding
  - margin
- 改变节点内部文字结构页面触发重布局
  - text-align
  - overflow-y
  - font-weight
  - overflow
  - font-family
  - line-height
  - vertical-align
  - white-space
  - font-size

### 重绘 repaint

repaint 或则 redraw 遍历所有的节点检测各节点的可见性，颜色，轮廓等可见的样式属性，然后根据检测的结果更新页面的响应部分

当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫做重绘

只触发重绘不触发重排的一些 css 属性:

- color
- background-style、border-radius
- visibility
- text-decoration
- background-color、background-image、background-position、background-repeat、background-size
- outline、outline-color、outline-style、outline-width
- box-shadow

```javascript
const bstyle = document.body.style;
bstyle.padding = "20px"; // reflow repaint
bstyle.border = "10px solid red"; // 再一次的 reflow repaint
bstyle.color = "blue"; // repaint
bstyle.backgroundColor = "gray"; // repaint
bstyle.fontSize = "2em"; // reflow repaint

// new DOM element - reflow repaint
document.body.appendChild(document.createElement("div"));
```

当然，我们的浏览器是聪明的，它不会向上面那样，你每改一次样式，它就 reflow 活着 repaint，一般来说，浏览器会把这样的操作赞成一批，然后一次 reflow，这又叫做异步 reflow 或增量 reflow，但是有一些情况浏览器是不会这么做的，比如 resize 窗口，改变了页面的默认字体等，浏览器会马上 reflow。但是有些时候我们的脚本会阻止浏览器这么干，比如，如果我们下面一些的一些 DOM 值：

减少重绘和重排
重绘和重排在实际开发中是很难避免的，我们能做的是就是尽量减少这种行为的发生

- js 尽量少访问 dom 节点和 css 属性，尽量不要过多的频繁去增加，修改，删除元素，因为这样可能会频繁的导致页面 reflow，可以先把该 dom 节点抽离到内存中进行复杂的操作后再 dispaly 到页面上（虚拟 dom）
- 减少不必要的 DOM 层级，改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点，这导致大量时间消费在执行 reflow 上面
- 不要通过父级来改变子元素的样式，最好直接改变子元素的样式，改变子元素的样式尽可能不要影响父元素和兄弟元素的大小和尺寸
- 尽量通过 class 来设计元素的样式，切记用 style 来操作单个属性

```javascript
// bad
const left = 0;
const top = 10;
element.style.left = left + "px";
element.style.top = top + "px";
// Good
element.className = "the classname";
// Good
el.style.cssText += `; left: ${left}px; top: ${top}px;`;
```

- 尽可能的为产生动画的 HTML 元素使用 fixed 或 absolute 的 position，那么修改它的 css 是不会 Reflow 的
- img 标签要设置宽高，以减少重绘和重排
- 把 DOM 离线后修改，如将一个 dom 脱离文档流，比如 display: none,再修改属性，这里只发生一次回流。
- 尽量用 transform 来做形变和位移，不会造成回流
- 权衡速度的平滑，比如实现一个动画，以 1 个像素单位移动这样最平滑，但 reflow 就会频繁，CPU 很快就会完全占用，如果以三个像素为单位移动就会好很多
- 不要用 table 布局的另一个原因就是 table 中某个元素一旦触发 reflow 就会导致 table 里面所有的其他元素 reflow，在适合用 table 的场合，可以设置 table-layout 为 auto 或 fixed
- 避免不必要的复杂的 css 选择器，尤其是后代选择器，因为为了匹配选择器将耗费更多的 CPU
  > display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化

总结一下:
重排: 元素的尺寸变了，位置变化了
重绘: 元素的背景色变了，文字颜色变了，边框颜色变了，可见性变了，透明度变了，元素的尺寸没有任何变化
Reflow的成本比Repaint的成本高的多得多，DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父结点的reflow。在一些高性能的电脑上也许没有什么，但是reflow如果发生在手机上，那么这个过程是非常痛快和耗电的

## 页面加载缓慢的原因
- 网络层面
  1. 过多的http请求，打开一个页面的时候，后台程序响应并不所需太多时间，等待的时间主要花费在下载网页元素上，即HTML、CSS、Javascript、Flash、图片等。每增加一个元素，网页载入的时间就会增加25-40ms（具体取决用户的带宽情况）
      - 合并文件：将多个CSS文件或JavaScript文件合并成一个文件，减少HTTP请求的数量。
      - CSS Sprites：将多个小图片合并成一张大图（雪碧图），通过CSS background-position来显示不同的图片，减少图片的HTTP请求
      - 图像优化：对图片进行压缩和优化，减小图片文件的大小，减少下载时间。
      - 使用CDN：将静态资源部署到内容分发网络（CDN）上，加速资源的加载速度，减少网络延迟。
      - 延迟加载：对于一些非关键资源，可以延迟它们的加载时间，等页面主要内容加载完成后再加载这些资源。
  2. 资源访问带宽小，两方面，一方面是客户端的带宽，一方面是服务端的带宽
  3. 网页元素（图片，视频，样式）太大
- 浏览器渲染层面
  1. 渲染阻塞

    浏览器渲染一个页面就必须先构建出DOM树和CSSOM树，如果HTML和CSS文件结构非常庞大与复杂，这显然会给页面加载速度带来严重影响

    渲染阻塞资源是指在浏览器加载网页时，某些资源（比如CSS或JavaScript文件）的加载和执行会阻塞页面的渲染过程。当浏览器遇到需要加载的CSS或JavaScript资源时，它会暂停渲染页面，先加载并解析这些资源，然后才能继续构建DOM树和CSSOM树，最终进行页面的渲染

    这种行为会延迟页面的渲染操作开始时间，因为浏览器必须等待所有必要的资源加载完成后才能开始渲染页面内容。为了减少渲染阻塞资源对页面性能的影响，可以采取一些优化措施，比如：

          - 异步加载资源：对于不影响页面布局和内容的资源，可以使用async或defer属性来异步加载资源，使其不阻塞页面的渲染。
          - 优化资源加载顺序：将关键资源放在文档头部加载，将非关键资源放在文档底部加载，以确保关键内容能够尽快渲染出来。
          - 使用资源合并和压缩：将多个小文件合并成一个大文件，并对文件进行压缩，减少资源加载次数和加载时间
          - 使用CDN加速：将静态资源部署到内容分发网络（CDN）上，加速资源的加载速度。
    js阻塞和css阻塞：
    **HTML、CSS、Javscript都是会对渲染产生阻塞的资源，HTML是必须的（没有DOM还谈何渲染），但还可以从CSS与Javascript着手优化，尽可能的减少阻塞的产生**

  2. 重复渲染
  3. DNS解析
- 服务端层面
  1. 硬件配置低，这个是双向的
  2. 服务器软件，比如防火墙，内网策略等
  3. 未对Nginx这类web服务器进行配置优化
  4. CPU占满，数据库未优化
  5. 代码问题，代码效率，代码性能
  6. 包含过多的分析类工具
### 代码部分
- 构建层面
  未对代码进行打包，压缩，兼容性优化
  未合并重复请求，代码
- 编码层面
  没有良好的习惯，错误的排板JS和CSS
  for循环、迭代、同步、重定向、阻塞请求
  未删除重复，无用的代码
  未对逻辑业务复杂的代码进行重构，了解设计模式，对业务进行梳理
- SSR
  未加入Async异步机制
  未思考页面加载，用户体验
- 规范
  CSS规范
  HTML/HTML5规范
  Airbnb JavaScript规范
### 优化原则