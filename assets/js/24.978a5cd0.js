(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{317:function(t,s,a){"use strict";a.r(s);var v=a(10),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"页面性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面性能优化"}},[t._v("#")]),t._v(" 页面性能优化")]),t._v(" "),s("p",[t._v("前端性能优化可以分为两大部分，浏览器和代码部分"),s("br"),t._v("\n浏览器部分又可以分为:")]),t._v(" "),s("ul",[s("li",[t._v("网络层面")]),t._v(" "),s("li",[t._v("浏览器渲染层面")]),t._v(" "),s("li",[t._v("服务端层面")])]),t._v(" "),s("p",[t._v("代码部分又可以分为:")]),t._v(" "),s("ul",[s("li",[t._v("构建层面")]),t._v(" "),s("li",[t._v("编码层面")]),t._v(" "),s("li",[t._v("机制(SSR,英文 Server Side Render：服务端渲染)")]),t._v(" "),s("li",[t._v("规范\n首先看看浏览器部分，前端页面主要在浏览器上运行，那么我们追根溯源，从浏览器的原理开始，研究如何进行页面性能优化")])]),t._v(" "),s("h2",{attrs:{id:"浏览器组成部分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器组成部分"}},[t._v("#")]),t._v(" 浏览器组成部分")]),t._v(" "),s("ol",[s("li",[t._v("用户界面")]),t._v(" "),s("li",[t._v("浏览器引擎（browser engine）- 在用户界面和渲染引擎之间传递指令")]),t._v(" "),s("li",[s("strong",[t._v("渲染引擎")]),t._v("（rendering engine）- 负责显示请求的内容\n浏览器（Firefox、chrome、Safari）是基于两种渲染引擎构建的，Firefox 使用的是 Gecko 引擎，chrome 和 Safari 使用的是 Webkit 引擎，Webkit 引擎又分为渲染引擎和 JS 引擎，渲染引擎负责显示请求的内容，JS 引擎负责解析和执行 JS 代码")]),t._v(" "),s("li",[t._v("网络（Networking）- 用于网络调用，比如 HTTP 请求")]),t._v(" "),s("li",[t._v("UI 后端（UI Backend）- 用于绘制基本的窗口小部件，比如组合框和窗口")]),t._v(" "),s("li",[t._v("Javascript 解释器（Javascript Interpreter）- 用于解析和执行 Javascript 代码，如 V8 引擎\njs 引擎线层负责解析 javascript 脚本,运行代码。\n"),s("strong",[t._v("JS 引擎一直等待任务队列中任务的到来，然后加以处理，一个 Tab 页面中只有一个 js 线层在运行")])]),t._v(" "),s("li",[t._v("数据存储（data storage）- 负责将渲染引擎输出的内容进行持久化存储，例如 cookie，新的 HTML5 定义了网络数据库，这是一个完成的浏览器内数据库")])]),t._v(" "),s("h2",{attrs:{id:"浏览器是多进程的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器是多进程的"}},[t._v("#")]),t._v(" 浏览器是多进程的")]),t._v(" "),s("p",[t._v("进程线层简单理解，进程里面可以有多个线层，进程是 QQ，线层是会话")]),t._v(" "),s("ul",[s("li",[t._v("浏览器是多进程的")]),t._v(" "),s("li",[t._v("浏览器之所以能够运行，是因为系统给他的进程分配了资源(CPU、内存、磁盘)")]),t._v(" "),s("li",[t._v("简单理解每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程\n浏览器里面的进程：")])]),t._v(" "),s("ol",[s("li",[s("p",[t._v("Browser 进程，浏览器的主要进程（负责协调和主控），只有一个。作用有：")]),t._v(" "),s("ul",[s("li",[t._v("负责浏览器界面显示，与用户交互。如前进、后退等")]),t._v(" "),s("li",[t._v("负责各个页面的管理，创建和销毁其他进程")]),t._v(" "),s("li",[t._v("将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上")]),t._v(" "),s("li",[t._v("网络资源的管理，下载等")])])]),t._v(" "),s("li",[s("p",[t._v("第三方插件进程，每种类型的插件对应一个进程，多个插件进程可能同时存在。仅当使用了该插件才创建")])]),t._v(" "),s("li",[s("p",[t._v("GPU 进程，最多一个，用于 3D 绘制等")])]),t._v(" "),s("li",[s("p",[t._v("浏览器渲染进程（浏览器内核），内部是多线层的")]),t._v(" "),s("ul",[s("li",[t._v("默认每个 Tab 页面一个进程，互不影响")]),t._v(" "),s("li",[t._v("主要作用为页面渲染，脚本执行，事件处理等")])])])]),t._v(" "),s("p",[t._v("渲染进程是多线层的：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("GUI 渲染线层")]),t._v(" "),s("ul",[s("li",[t._v("负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等")]),t._v(" "),s("li",[t._v("当界面需要重绘制（Repaint）或某种操作引发的回流（Reflow），该线层就会执行")]),t._v(" "),s("li",[t._v("注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。")])])]),t._v(" "),s("li",[s("p",[t._v("JS 引擎线层")]),t._v(" "),s("ul",[s("li",[t._v("也称为 JS 内核，负责处理 Javascript 脚本程序（包括解析和执行），例如 V8 引擎")]),t._v(" "),s("li",[t._v("JS 引擎线层负责解析 JS 脚本，运行代码")]),t._v(" "),s("li",[t._v("JS 引擎一直等待任务队列中任务的到来，然后加以处理，一个 Tab 页面中只有一个 JS 引擎在运行")]),t._v(" "),s("li",[t._v("注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，要放在 Body 下面，负责会导致页面渲染加载阻塞")])])]),t._v(" "),s("li",[s("p",[t._v("事件触发线程")]),t._v(" "),s("ul",[s("li",[t._v("管理事件队列")]),t._v(" "),s("li",[t._v("监听事件，符合条件时把回调函数放入事件队列中")])])]),t._v(" "),s("li",[s("p",[t._v("定时触发器线层")]),t._v(" "),s("ul",[s("li",[t._v("setInterval 与 setTimeout 在此线层中计时完毕，把回调函数放入事件队列")]),t._v(" "),s("li",[t._v("浏览器定时计数并不是由 Javascript 引擎计数的，由单独的定时计数器线程来计时，计时完毕后，添加到事件队列中，等待 JS 引擎空闲时执行（因为 Javascript 引擎是单线程的，如果处于阻塞线层状态就会影响计时的准确，因此通过单独的线层来计时并触发定时（计时完毕后，添加到时间队列中，等待 JS 引擎空闲后执行）")])])]),t._v(" "),s("li",[s("p",[t._v("异步 http 请求线程")]),t._v(" "),s("ul",[s("li",[t._v("检测 XHR 对象状态的变化时，将回调函数添加到事件队列中")]),t._v(" "),s("li",[t._v("将检测到状态更新时，如果设置回调函数，异步线层就产生状态变更事件，将这个回调再放入事件队列中，由 javascript 引擎执行")])])])]),t._v(" "),s("p",[t._v("了解一下执行线:")]),t._v(" "),s("h2",{attrs:{id:"浏览器渲染机制简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制简介"}},[t._v("#")]),t._v(" 浏览器渲染机制简介")]),t._v(" "),s("p",[t._v("对于渲染，我们首先需要了解一个概念，设备刷新率。")]),t._v(" "),s("p",[t._v("设备刷新率是设备屏幕的渲染频率，通俗一点就是，把屏幕当作墙，设备刷新率就是多久刷新一次墙面，几本我们平常接触的设备，如手机、电脑等，刷新率一般为 60Hz，即每秒刷新 60 次。约 16.7ms 渲染一次屏幕"),s("br"),t._v("\n这就意味着，我们的浏览器最佳的渲染性能就是所有的操作都在 16.7ms 内完成，如果做到一帧内完成，那么浏览器渲染性能就最佳了。")]),t._v(" "),s("p",[t._v("渲染引擎一开始会从网络层获取请求文档的内容，内容大小一般限制在 8000 块以内"),s("br"),t._v("\n然后进行如下所示的"),s("strong",[t._v("几本流程:")]),t._v(" "),s("img",{attrs:{src:"/browser02.png",alt:"browser"}}),t._v("\n渲染引擎开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点，同时解析外部 CSS 文件以及样式元素中的数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构，呈现树。\n呈现树包含多个带有视觉属性(颜色和尺寸)的矩形，这些矩形的排列顺序就是它们将要在页面上的显示顺序。")]),t._v(" "),s("p",[t._v("呈现树构建完毕之后，进入“布局”处理阶段，也就是为节点分配一个应出现在屏幕上的确切坐标，下一阶段是"),s("strong",[t._v("绘制")]),t._v("，渲染引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来")]),t._v(" "),s("p",[t._v("需要着重指出的是，这是一个渐进的过程，为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上，它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局，在不断接受和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来")]),t._v(" "),s("p",[t._v("那么我们知道了，CSSOM 树和 DOM 树合并成渲染树，然后用户计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。优化上述每一个步骤对实现最佳渲染性能至关重要")]),t._v(" "),s("p",[t._v("具体流程为:")]),t._v(" "),s("ul",[s("li",[t._v("DOM 树与 CSS 树合并后形成渲染树")]),t._v(" "),s("li",[t._v("渲染树只包含渲染网页所需的节点")]),t._v(" "),s("li",[t._v("布局计算每个对象的精确位置和大小")]),t._v(" "),s("li",[t._v("最后一步是绘制，使用最终渲染树将像素渲染到屏幕上\n"),s("blockquote",[s("p",[t._v("请注意 visibility:hidden 和 display:none 的区别，前者元素仍在 DOM 树中，只是不可见，而后者元素不在 DOM 树中，因此，visibility:hidden 的元素不会影响计数器，而 display:none 的元素会影响计数器")])])])]),t._v(" "),s("p",[s("strong",[t._v("script 标签的处理")])]),t._v(" "),s("p",[t._v("JS 可以操作 DOM 来修改 DOM 结构，可以操作 CSSOM 来修改节点样式，这就导致了浏览器在解析 HTML 时，一旦碰到 script，就会立即停止 HTML 的解析（而 css 不会），执行 js，再返回控制权")]),t._v(" "),s("p",[t._v("事实上，JS 在执行前不仅仅是停止了 HTML 的解析，它还必须等待 CSS 的解析完成，当浏览器碰到 script 元素时，发现该元素当前的 css 还未解析完，就会等待 css 解析完毕，再去执行 js。")]),t._v(" "),s("p",[t._v("JS 阻塞了 HTML 的解析，也阻塞了其后的 css 解析，整个解析进程必须等待 JS 的执行完毕才能继续，这就是 JS 阻塞页面。一个 script 标签，推迟了 DOM 的生成，CSSOM 的生成以及之后的所有渲染过程，从性能角度上讲，将 script 放在页面底部，也就合情合理了。")]),t._v(" "),s("p",[t._v("简单来说，渲染线层和 JS 线程是互斥的，当 JS 执行时，渲染线程会被挂起，GUI 更新会被保存在一个队列中等待 JS 线程空闲时立即被执行。")]),t._v(" "),s("p",[t._v("总结一下浏览器的渲染流程:")]),t._v(" "),s("ul",[s("li",[t._v("DOM 树构建")]),t._v(" "),s("li",[t._v("CSSOM 树构建\n"),s("blockquote",[s("p",[t._v("css 加载不会阻塞 DOM 树的解析（异步加载时 DOM 树照常构建），但是会阻塞 render 树的渲染（渲染会等待 css 加载完毕，因为 render 树需要 css 信息）")])])]),t._v(" "),s("li",[t._v("布局")]),t._v(" "),s("li",[t._v("绘制")])]),t._v(" "),s("h2",{attrs:{id:"重排-reflow-和重绘-repaint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重排-reflow-和重绘-repaint"}},[t._v("#")]),t._v(" 重排 reflow 和重绘 repaint")]),t._v(" "),s("h3",{attrs:{id:"重排-reflow"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重排-reflow"}},[t._v("#")]),t._v(" 重排 reflow")]),t._v(" "),s("p",[t._v("relow 指的是重新计算页面布局\n某个节点 reflow 时会重新计算节点的尺寸和位置，而且还有可能触发其子节点，祖先节点和页面上的其他节点 reflow，在这之后再触发一次 repaint")]),t._v(" "),s("p",[t._v("当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就称为回流(reflow)，每一个页面至少需要一个回流在页面第一次加载的时候")]),t._v(" "),s("p",[t._v("导致 reflow 的操作")]),t._v(" "),s("ul",[s("li",[t._v("调整窗口大小")]),t._v(" "),s("li",[t._v("改变字体")]),t._v(" "),s("li",[t._v("增加或移除样式表")]),t._v(" "),s("li",[t._v("内容变化，比如用户在 input 框中输入文字")]),t._v(" "),s("li",[t._v("激活伪类，比如:hover")]),t._v(" "),s("li",[t._v("操作 class 属性")]),t._v(" "),s("li",[t._v("脚本操作 DOM")]),t._v(" "),s("li",[t._v("计算 offsetWidth 和 offsetHeight 等属性")]),t._v(" "),s("li",[t._v("设置 style")])]),t._v(" "),s("p",[t._v("触发页面重布局的 css 属性")]),t._v(" "),s("ul",[s("li",[t._v("盒模型相关的属性会触发重布局\n"),s("ul",[s("li",[t._v("width")]),t._v(" "),s("li",[t._v("height")]),t._v(" "),s("li",[t._v("padding")]),t._v(" "),s("li",[t._v("margin")])])]),t._v(" "),s("li",[t._v("改变节点内部文字结构页面触发重布局\n"),s("ul",[s("li",[t._v("text-align")]),t._v(" "),s("li",[t._v("overflow-y")]),t._v(" "),s("li",[t._v("font-weight")]),t._v(" "),s("li",[t._v("overflow")]),t._v(" "),s("li",[t._v("font-family")]),t._v(" "),s("li",[t._v("line-height")]),t._v(" "),s("li",[t._v("vertical-align")]),t._v(" "),s("li",[t._v("white-space")]),t._v(" "),s("li",[t._v("font-size")])])])]),t._v(" "),s("h3",{attrs:{id:"重绘-repaint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint"}},[t._v("#")]),t._v(" 重绘 repaint")]),t._v(" "),s("p",[t._v("repaint 或则 redraw 遍历所有的节点检测各节点的可见性，颜色，轮廓等可见的样式属性，然后根据检测的结果更新页面的响应部分")]),t._v(" "),s("p",[t._v("当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫做重绘")]),t._v(" "),s("p",[t._v("只触发重绘不触发重排的一些 css 属性:")]),t._v(" "),s("ul",[s("li",[t._v("color")]),t._v(" "),s("li",[t._v("background-style、border-radius")]),t._v(" "),s("li",[t._v("visibility")]),t._v(" "),s("li",[t._v("text-decoration")]),t._v(" "),s("li",[t._v("background-color、background-image、background-position、background-repeat、background-size")]),t._v(" "),s("li",[t._v("outline、outline-color、outline-style、outline-width")]),t._v(" "),s("li",[t._v("box-shadow")])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" bstyle "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nbstyle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("padding "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"20px"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// reflow repaint")]),t._v("\nbstyle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("border "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"10px solid red"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 再一次的 reflow repaint")]),t._v("\nbstyle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("color "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"blue"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// repaint")]),t._v("\nbstyle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("backgroundColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"gray"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// repaint")]),t._v("\nbstyle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fontSize "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2em"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// reflow repaint")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// new DOM element - reflow repaint")]),t._v("\ndocument"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("appendChild")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"div"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("当然，我们的浏览器是聪明的，它不会向上面那样，你每改一次样式，它就 reflow 活着 repaint，一般来说，浏览器会把这样的操作赞成一批，然后一次 reflow，这又叫做异步 reflow 或增量 reflow，但是有一些情况浏览器是不会这么做的，比如 resize 窗口，改变了页面的默认字体等，浏览器会马上 reflow。但是有些时候我们的脚本会阻止浏览器这么干，比如，如果我们下面一些的一些 DOM 值：")]),t._v(" "),s("p",[t._v("减少重绘和重排\n重绘和重排在实际开发中是很难避免的，我们能做的是就是尽量减少这种行为的发生")]),t._v(" "),s("ul",[s("li",[t._v("js 尽量少访问 dom 节点和 css 属性，尽量不要过多的频繁去增加，修改，删除元素，因为这样可能会频繁的导致页面 reflow，可以先把该 dom 节点抽离到内存中进行复杂的操作后再 dispaly 到页面上（虚拟 dom）")]),t._v(" "),s("li",[t._v("减少不必要的 DOM 层级，改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点，这导致大量时间消费在执行 reflow 上面")]),t._v(" "),s("li",[t._v("不要通过父级来改变子元素的样式，最好直接改变子元素的样式，改变子元素的样式尽可能不要影响父元素和兄弟元素的大小和尺寸")]),t._v(" "),s("li",[t._v("尽量通过 class 来设计元素的样式，切记用 style 来操作单个属性")])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// bad")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" top "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nelement"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"px"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nelement"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("top "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" top "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"px"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Good")]),t._v("\nelement"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("className "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"the classname"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Good")]),t._v("\nel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cssText "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("; left: ")]),s("span",{pre:!0,attrs:{class:"token interpolation"}},[s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("px; top: ")]),s("span",{pre:!0,attrs:{class:"token interpolation"}},[s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("top"),s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("px;")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("ul",[s("li",[t._v("尽可能的为产生动画的 HTML 元素使用 fixed 或 absolute 的 position，那么修改它的 css 是不会 Reflow 的")]),t._v(" "),s("li",[t._v("img 标签要设置宽高，以减少重绘和重排")]),t._v(" "),s("li",[t._v("把 DOM 离线后修改，如将一个 dom 脱离文档流，比如 display: none,再修改属性，这里只发生一次回流。")]),t._v(" "),s("li",[t._v("尽量用 transform 来做形变和位移，不会造成回流")]),t._v(" "),s("li",[t._v("权衡速度的平滑，比如实现一个动画，以 1 个像素单位移动这样最平滑，但 reflow 就会频繁，CPU 很快就会完全占用，如果以三个像素为单位移动就会好很多")]),t._v(" "),s("li",[t._v("不要用 table 布局的另一个原因就是 table 中某个元素一旦触发 reflow 就会导致 table 里面所有的其他元素 reflow，在适合用 table 的场合，可以设置 table-layout 为 auto 或 fixed")]),t._v(" "),s("li",[t._v("避免不必要的复杂的 css 选择器，尤其是后代选择器，因为为了匹配选择器将耗费更多的 CPU\n"),s("blockquote",[s("p",[t._v("display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化")])])])]),t._v(" "),s("p",[t._v("总结一下:\n重排: 元素的尺寸变了，位置变化了\n重绘: 元素的背景色变了，文字颜色变了，边框颜色变了，可见性变了，透明度变了，元素的尺寸没有任何变化\nReflow 的成本比 Repaint 的成本高的多得多，DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父结点的 reflow。在一些高性能的电脑上也许没有什么，但是 reflow 如果发生在手机上，那么这个过程是非常痛快和耗电的")]),t._v(" "),s("h2",{attrs:{id:"页面加载缓慢的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面加载缓慢的原因"}},[t._v("#")]),t._v(" 页面加载缓慢的原因")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("网络层面")]),t._v(" "),s("ol",[s("li",[t._v("过多的 http 请求，打开一个页面的时候，后台程序响应并不所需太多时间，等待的时间主要花费在下载网页元素上，即 HTML、CSS、Javascript、Flash、图片等。每增加一个元素，网页载入的时间就会增加 25-40ms（具体取决用户的带宽情况）\n"),s("ul",[s("li",[t._v("合并文件：将多个 CSS 文件或 JavaScript 文件合并成一个文件，减少 HTTP 请求的数量。")]),t._v(" "),s("li",[t._v("CSS Sprites：将多个小图片合并成一张大图（雪碧图），通过 CSS background-position 来显示不同的图片，减少图片的 HTTP 请求")]),t._v(" "),s("li",[t._v("图像优化：对图片进行压缩和优化，减小图片文件的大小，减少下载时间。")]),t._v(" "),s("li",[t._v("使用 CDN：将静态资源部署到内容分发网络（CDN）上，加速资源的加载速度，减少网络延迟。")]),t._v(" "),s("li",[t._v("延迟加载：对于一些非关键资源，可以延迟它们的加载时间，等页面主要内容加载完成后再加载这些资源。")])])]),t._v(" "),s("li",[t._v("资源访问带宽小，两方面，一方面是客户端的带宽，一方面是服务端的带宽")]),t._v(" "),s("li",[t._v("网页元素（图片，视频，样式）太大")])])]),t._v(" "),s("li",[s("p",[t._v("浏览器渲染层面")]),t._v(" "),s("ol",[s("li",[t._v("渲染阻塞")])]),t._v(" "),s("p",[t._v("浏览器渲染一个页面就必须先构建出 DOM 树和 CSSOM 树，如果 HTML 和 CSS 文件结构非常庞大与复杂，这显然会给页面加载速度带来严重影响")]),t._v(" "),s("p",[t._v("渲染阻塞资源是指在浏览器加载网页时，某些资源（比如 CSS 或 JavaScript 文件）的加载和执行会阻塞页面的渲染过程。当浏览器遇到需要加载的 CSS 或 JavaScript 资源时，它会暂停渲染页面，先加载并解析这些资源，然后才能继续构建 DOM 树和 CSSOM 树，最终进行页面的渲染")]),t._v(" "),s("p",[t._v("这种行为会延迟页面的渲染操作开始时间，因为浏览器必须等待所有必要的资源加载完成后才能开始渲染页面内容。为了减少渲染阻塞资源对页面性能的影响，可以采取一些优化措施，比如：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("    - 异步加载资源：对于不影响页面布局和内容的资源，可以使用async或defer属性来异步加载资源，使其不阻塞页面的渲染。\n    - 优化资源加载顺序：将关键资源放在文档头部加载，将非关键资源放在文档底部加载，以确保关键内容能够尽快渲染出来。\n    - 使用资源合并和压缩：将多个小文件合并成一个大文件，并对文件进行压缩，减少资源加载次数和加载时间\n    - 使用CDN加速：将静态资源部署到内容分发网络（CDN）上，加速资源的加载速度。\n")])])]),s("p",[t._v("js 阻塞和 css 阻塞：\n"),s("strong",[t._v("HTML、CSS、Javscript 都是会对渲染产生阻塞的资源，HTML 是必须的（没有 DOM 还谈何渲染），但还可以从 CSS 与 Javascript 着手优化，尽可能的减少阻塞的产生")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("重复渲染")]),t._v(" "),s("li",[t._v("DNS 解析")])])]),t._v(" "),s("li",[s("p",[t._v("服务端层面")]),t._v(" "),s("ol",[s("li",[t._v("硬件配置低，这个是双向的")]),t._v(" "),s("li",[t._v("服务器软件，比如防火墙，内网策略等")]),t._v(" "),s("li",[t._v("未对 Nginx 这类 web 服务器进行配置优化")]),t._v(" "),s("li",[t._v("CPU 占满，数据库未优化")]),t._v(" "),s("li",[t._v("代码问题，代码效率，代码性能")]),t._v(" "),s("li",[t._v("包含过多的分析类工具")])])])]),t._v(" "),s("h3",{attrs:{id:"代码部分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码部分"}},[t._v("#")]),t._v(" 代码部分")]),t._v(" "),s("ul",[s("li",[t._v("构建层面\n未对代码进行打包，压缩，兼容性优化\n未合并重复请求，代码")]),t._v(" "),s("li",[t._v("编码层面\n没有良好的习惯，错误的排板 JS 和 CSS\nfor 循环、迭代、同步、重定向、阻塞请求\n未删除重复，无用的代码\n未对逻辑业务复杂的代码进行重构，了解设计模式，对业务进行梳理")]),t._v(" "),s("li",[t._v("SSR\n未加入 Async 异步机制\n未思考页面加载，用户体验")]),t._v(" "),s("li",[t._v("规范\nCSS 规范\nHTML/HTML5 规范\nAirbnb JavaScript 规范")])]),t._v(" "),s("h3",{attrs:{id:"优化原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化原则"}},[t._v("#")]),t._v(" 优化原则")]),t._v(" "),s("ol",[s("li",[t._v("减少 HTTP 请求次数")]),t._v(" "),s("li",[t._v("使用内容分发网络")]),t._v(" "),s("li",[t._v("开启 gzip 压缩")]),t._v(" "),s("li",[t._v("css 放在顶部，js 放在底部\n当浏览器遇到 script 标签时，它会停止解析 HTML，下载并执行脚本，然后再继续解析剩余的 HTML。这可能会导致页面加载速度变慢，尤其是对于位于 head 部分的脚本，因为它们会延迟文档的渲染和显示。")])]),t._v(" "),s("p",[t._v("为了避免这种情况，可以使用 async 或 defer 属性来优化脚本加载。使用这两个属性可以让浏览器在下载脚本的同时继续解析 HTML，提高页面加载性能。async 属性会异步加载并执行脚本，而 defer 属性会按顺序加载脚本并在文档解析完成后执行")]),t._v(" "),s("p",[t._v("async 和 defer 区别，当浏览器解析 html 的时候遇到 defer 属性的 script 标签，会立即下载，但是不会立即执行，会等到 html 文档解析完毕 DOMContentLoaded 事件触发之间按循序执行，async 属性的脚本，浏览器会立刻下载，下载完毕马上执行，但是下载的时候不会阻塞 HTML 的解析，适合哪些不需要按循序执行的脚本，比如统计相关")]),t._v(" "),s("ol",{attrs:{start:"5"}},[s("li",[s("p",[t._v("减少 DNS 查找\n用户访问网站的过程如下")]),t._v(" "),s("ol",[s("li",[t._v("在地址栏输入地址，wwww.example.com;")]),t._v(" "),s("li",[t._v("本地 DNS 得到这个请求，查询本地 DNS 缓存，如果有这条记录，则返回对应的 IP 地址，否则，请求网络上的 DNS 服务器，得到 IP 地址，并返回给本地 DNS 服务器，本地 DNS 服务器将这个 IP 地址缓存起来，下次再访问这个网站，直接返回 IP 地址；")]),t._v(" "),s("li",[t._v("浏览器向得到的 IP 地址发送网络请求，得到响应后建立连接，请求数据")]),t._v(" "),s("li",[t._v("server 端计算所需要数据，并返回给 client 端")]),t._v(" "),s("li",[t._v("client 端，即浏览器，解析数据并显示在浏览器窗口，至此请求完成")])])])]),t._v(" "),s("p",[t._v("在一次请求中 DNS 解析可以占到请求的三分之一的时间，所以可以缩短 DNS 解析时间，就可以加快页面的打开速度")]),t._v(" "),s("p",[t._v("缩短 DNS 解析的方法可以通过延长 DNS 缓存时间，选用更快的 DNS Server，减少域名总数，如原来有五个 Image Server，分别为 imgae1.xxx.com 至 image5.xxx.com，现在改为 image1.xxx.com 至 image3.xxx.com，这样就减少了域名总数，DNS 解析时间也会相应减少，但是减少域名个数又会降低资源并发下载数量，因为同一个域名最多可以下载两个资源，所以这里需要一个折中方案。")]),t._v(" "),s("p",[t._v("使用 DNS 预解析\n使用 link 标签，在 head 标签中加入 dns-prefetch，这样浏览器在解析到这个标签时，就会提前去解析这个域名，从而缩短 DNS 解析时间\ndns-prefetch 是 HTML5 中新增的标签，可以用来告诉浏览器提前解析某个域名，从而缩短 DNS 解析时间，但是需要慎用，多页面重复 dns 预解析会增加重复 DNS 查询次数\n6. 压缩资源（webpack，gulp，tree-shaking）\n7. 避免重定向和找不到资源，注意在路径后面需要加入/避免重定向\n8. ajax优化\n9. cookie优化\n10. 利用缓存")])])}),[],!1,null,null,null);s.default=_.exports}}]);